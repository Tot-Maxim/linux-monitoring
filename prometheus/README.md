4. **Лейбл (Label)** — это пара ключ-значение, добавляющая контекст к метрике. Например, метрика `http_requests_total` может иметь лейблы `method="POST"`, `path="/api"`, `status_code="200"`, что позволяет группировать и фильтровать данные.

   #### Как используются лейблы в PromQL?
   
   - Фильтрация:  
     `http_requests_total{status="500"}`         # Выведет только 500-ые статусы по лейблу **status**
   - Группировка:  
     `sum by (method) (http_requests_total)`     # Отсортирует сумму по лейблу **method** каждого HTTP запроса
   - Агрегация:  
     `rate(http_requests_total{job="api"}[5m])`  # Cчитает прирост значения метрики за последние 5 минут при обращении к лейблу **job**

5. **Временной ряд (Time Series)** в Prometheus — это последовательность данных, которая описывает изменение метрики во времени. Каждый временной ряд состоит из:

   1. **Имени метрики** (например, `http_requests_total`).
   2. **Набора лейблов** (например, `method="GET"`, `status="200"`, `job="api"`).
   3. **Набора значений**, где каждое значение привязано к определённому моменту времени.

   #### Пример временного ряда:
   ```plaintext
   http_requests_total{method="GET", status="200", job="api"} @timestamp1 => 100
   http_requests_total{method="GET", status="200", job="api"} @timestamp2 => 150
   http_requests_total{method="GET", status="200", job="api"} @timestamp3 => 200
   ```
   Здесь:
   - **Имя метрики**: `http_requests_total`.
   - **Лейблы**: `method="GET"`, `status="200"`, `job="api"`.
   - **Значения**: `100`, `150`, `200` (привязанные к моментам времени `timestamp1`, `timestamp2`, `timestamp3`).



     #### Как временные ряды используются в Prometheus?
      1. **Хранение данных**:  
         Prometheus хранит данные в виде временных рядов. Каждый временной ряд уникально идентифицируется комбинацией имени метрики и лейблов.
      
      2. **Запросы (PromQL)**:  
         Временные ряды используются для анализа данных. Например, вы можете запросить:  
         - Текущее значение:  
           ```promql
           http_requests_total{job="api"}
           ```
         - Скорость изменения:  
           ```promql
           rate(http_requests_total{job="api"}[5m])
           ```
      
      3. **Визуализация**:  
         Временные ряды используются в Grafana или других инструментах для построения графиков.
      
      4. **Алертинг**:  
         На основе временных рядов можно настраивать правила алертинга. Например:  
         ```promql
         rate(http_requests_total{job="api"}[5m]) > 100
         ```
      
      
      #### Как временные ряды создаются?
      1. **Экспортеры**:  
         Экспортеры (например, Node Exporter, Blackbox Exporter) собирают данные и отправляют их в Prometheus в виде временных рядов.
      
      2. **Pushgateway**:  
         Для задач с коротким сроком жизни (например, cron-задачи) данные могут быть отправлены через Pushgateway.
   
6. **Экспортер (Exporter)**
   
   Это специальная программа или сервис, который собирает метрики из внешней системы (например, операционная система, база данных, аппаратное обеспечение) и предоставляет их в формате, понятном Prometheus. Экспортер действует как мост между целевой системой и Prometheus, преобразуя данные в метрики, которые Prometheus может собирать.

      1. **Сбор метрик**:
         - Экспортер собирает данные из целевой системы (например, использование CPU, память, количество запросов к базе данных).
         - Эти данные преобразуются в метрики в формате Prometheus.
      
      2. **Предоставление метрик**:
         - Экспортер предоставляет метрики через HTTP-эндпоинт, обычно в виде простого текстового формата.
         - Пример вывода:
           ```plaintext
           # HELP node_cpu_seconds_total Seconds the CPUs spent in each mode.
           # TYPE node_cpu_seconds_total counter
           node_cpu_seconds_total{cpu="0",mode="user"} 12345.67
           node_cpu_seconds_total{cpu="0",mode="system"} 6789.01
           ```
      
      3. **Сбор метрик Prometheus**:
         - Prometheus периодически запрашивает (вытягивает) метрики с экспортера по HTTP.
         - В конфигурации Prometheus указывается адрес экспортера:
           ```yaml
           scrape_configs:
             - job_name: 'node_exporter'
               static_configs:
                 - targets: ['localhost:9100']
           ```
      
      4. **Анализ и визуализация**:
         - Собранные метрики можно анализировать с помощью PromQL и визуализировать в Grafana.

7. **PromQL**
   
   Это язык запросов для работы с временными рядами в Prometheus. Он позволяет фильтровать, агрегировать и анализировать метрики, вычислять скорости изменения (rate), перцентили (histogram_quantile) и прогнозировать тренды (predict_linear). Используется для мониторинга, визуализации и настройки оповещений. Прост в использовании, но мощный для анализа производительности систем.

   Таблицы с основными функциями агрегирования и запросов в Prometheus, структурированные по категориям:

   #### Таблица 1: Основные агрегирующие функции
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `sum()` | Сумма значений | `sum(http_requests_total)` |
   | `avg()` | Среднее значение | `avg(http_request_duration_seconds)` |
   | `max()` | Максимальное значение | `max(node_memory_MemTotal)` |
   | `min()` | Минимальное значение | `min(node_cpu_seconds_total)` |
   | `stddev()` | Стандартное отклонение | `stddev(http_request_duration_seconds)` |
   | `stdvar()` | Дисперсия | `stdvar(http_request_duration_seconds)` |
   | `count()` | Количество элементов | `count(http_requests_total)` |
   
   ---
   
   #### Таблица 2: Функции для работы со временем
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `rate()` | Скорость изменения за интервал времени | `rate(http_requests_total[5m])` |
   | `irate()` | Скорость изменения между последними двумя точками | `irate(http_requests_total[5m])` |
   | `delta()` | Разница между первым и последним значением | `delta(node_filesystem_free[1h])` |
   | `increase()` | Увеличение счетчика за интервал времени | `increase(http_requests_total[1h])` |
   | `time()` | Текущее время в секундах с Unix epoch | `time()` |
   
   ---
   
   #### Таблица 3: Функции для распределений и квантилей
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `histogram_quantile(φ, ...)` | Расчет квантиля из histogram | `histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))` |
   | `quantile_over_time(φ, ...)` | Расчет квантиля за временной интервал | `quantile_over_time(0.95, http_request_duration_seconds[5m])` |
   | `avg_over_time(...)` | Среднее значение за временной интервал | `avg_over_time(http_request_duration_seconds[5m])` |
   | `max_over_time(...)` | Максимальное значение за временной интервал | `max_over_time(http_request_duration_seconds[5m])` |
   | `min_over_time(...)` | Минимальное значение за временной интервал | `min_over_time(http_request_duration_seconds[5m])` |
   
   ---
   
   #### Таблица 4: Функции для группировки и фильтрации
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `by` | Группировка по указанным меткам | `sum(http_requests_total) by (method)` |
   | `without` | Исключение указанных меток из группировки | `sum(http_requests_total) without (instance)` |
   | `label_replace()` | Замена меток | `label_replace(http_requests_total, "new_label", "$1", "old_label", "(.*)")` |
   | `label_join()` | Объединение меток | `label_join(http_requests_total, "combined", "_", "label1", "label2")` |
   
   ---
   
   #### Таблица 5: Математические и логические функции
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `abs()` | Абсолютное значение | `abs(http_request_duration_seconds)` |
   | `ceil()` | Округление вверх | `ceil(http_request_duration_seconds)` |
   | `floor()` | Округление вниз | `floor(http_request_duration_seconds)` |
   | `round()` | Округление до ближайшего целого | `round(http_request_duration_seconds)` |
   | `clamp_min()` | Ограничение минимального значения | `clamp_min(http_request_duration_seconds, 0)` |
   | `clamp_max()` | Ограничение максимального значения | `clamp_max(http_request_duration_seconds, 10)` |
   
   ---
   
   #### Таблица 6: Логические операторы
   
   | Оператор | Описание | Пример использования |
   |----------|----------|----------------------|
   | `==` | Равно | `http_requests_total == 100` |
   | `!=` | Не равно | `http_requests_total != 0` |
   | `>` | Больше | `http_request_duration_seconds > 1` |
   | `<` | Меньше | `http_request_duration_seconds < 0.5` |
   | `>=` | Больше или равно | `http_requests_total >= 100` |
   | `<=` | Меньше или равно | `http_request_duration_seconds <= 2` |
   
   ---
   
   #### Таблица 7: Встроенные константы и функции
   
   | Константа/Функция | Описание | Пример использования |
   |--------------------|----------|----------------------|
   | `up` | Состояние доступности таргета (1 - доступен, 0 - недоступен) | `up{job="api"}` |
   | `time()` | Текущее время в секундах с Unix epoch | `time()` |
   | `scalar()` | Преобразование в скалярное значение | `scalar(sum(http_requests_total))` |
   | `vector()` | Преобразование в вектор | `vector(1)` |
   
   ---
   
   #### Комментарий к таблицам:
   
   1. **Агрегирующие функции** (`sum`, `avg`, `max`, `min`) используются для объединения данных.
   2. **Функции для работы со временем** (`rate`, `irate`, `delta`, `increase`) помогают анализировать динамику изменений.
   3. **Функции для распределений и квантилей** (`histogram_quantile`, `quantile_over_time`) применяются для анализа гистограмм и summary метрик.
   4. **Группировка и фильтрация** (`by`, `without`, `label_replace`) позволяют управлять метками и группировать данные.
   5. **Математические и логические функции** обеспечивают возможность выполнять различные преобразования и сравнения.
   
   Эти таблицы можно использовать как справочник при написании запросов в Prometheus.


8. **Сервис-дискавери (Service Discovery)**  
    #### Что это:
    Service Discovery — это механизм, который позволяет автоматически обнаруживать сервисы или цели мониторинга в динамических средах. Это особенно важно в современных облачных и контейнеризированных инфраструктурах, где сервисы могут появляться и исчезать динамически (например, в Kubernetes).
    
    #### Как работает:
    Prometheus поддерживает несколько методов Service Discovery, которые позволяют ему автоматически находить и добавлять целевые адреса для сбора метрик. Вот основные типы дискавери:
    
    - **File-based SD**: Prometheus читает список целей из файла, который может быть регулярно обновляемым.
    - **DNS-based SD**: Использует DNS записи для обнаружения новых целей.
    - **Kubernetes SD**: Интеграция с API Kubernetes для автоматического отслеживания подов, сервисов и других ресурсов.
    - **AWS SD**: Обнаружение целей через API AWS (EC2 инстансы, ELB и т.д.).
    - **Consul SD**: Интеграция с HashiCorp Consul для обнаружения сервисов.
    
    #### Архитектурные особенности:
    - Prometheus периодически запрашивает источник Service Discovery для получения актуального списка целей.
    - При изменении инфраструктуры (например, создание нового пода в Kubernetes), Prometheus автоматически обновляет свои цели без необходимости перезапуска.
    - Поддерживается фильтрация целей с помощью label'ов.
    
    #### Практическое применение:
    - В Kubernetes: автоматическое добавление подов с метками `app=example` для мониторинга.
    - В AWS: мониторинг EC2 инстансов, которые соответствуют определенным тегам.
    - В локальных сетях: использование DNS для отслеживания серверов.
    
    #### Преимущества:
    - Упрощение конфигурации в динамических средах.
    - Автоматическая адаптация к изменениям инфраструктуры.
    - Снижение вероятности пропуска новых сервисов при масштабировании.
     
9. **Alertmanager**  
    #### Что это:
    Alertmanager — это компонент экосистемы Prometheus, предназначенный для управления алертами. Он принимает алерты от Prometheus, группирует их, подавляет ненужные уведомления и доставляет их в различные системы оповещения.
    
    #### Как работает:
    Alertmanager работает следующим образом:
    1. Prometheus отправляет алерты на Alertmanager, когда определенные условия выполняются (например, высокая загрузка CPU).
    2. Alertmanager применяет правила маршрутизации для определения получателя уведомления.
    3. Алерты могут быть сгруппированы по общим меткам (например, по сервису или окружению).
    4. Alertmanager отправляет уведомления через настроенные каналы связи (email, Slack, PagerDuty, webhook и т.д.).
    
    #### Основные функции:
    - **Группировка алертов**: Объединяет связанные алерты для предотвращения "шума" (например, все алерты одного сервиса отправляются одним сообщением).
    - **Mute-периоды**: Возможность временно отключать оповещения для определенных условий.
    - **Отложенные оповещения**: Настраиваемые задержки перед отправкой уведомлений.
    - **Маршрутизация**: Гибкая система правил для направления алертов разным получателям.
    - **Эскалация**: Автоматическое повышение уровня важности алерта при отсутствии реакции.
    
    #### Конфигурация:
    Конфигурация Alertmanager происходит через YAML-файл, где можно задать:
    - Маршруты оповещений.
    - Ресиверы (получатели) для разных типов уведомлений.
    - Настройки повторных отправок и mute-периодов.
    
    #### Практическое применение:
    - Отправка уведомлений в Slack о критических проблемах.
    - Интеграция с системами incident management (например, PagerDuty).
    - Автоматическое создание тикетов в Jira при возникновении проблем.
    
    #### Преимущества:
    - Централизованное управление алертами.
    - Защита от информационного шума за счет группировки и эскалации.
    - Гибкая настройка каналов оповещения.
     
10. **Pushgateway**  
    #### Что это:
    Pushgateway — это промежуточный сервис, который используется для сбора метрик от задач с коротким сроком жизни (например, cron-задач или batch-процессов). В отличие от стандартного подхода Prometheus (pull-модель), Pushgateway позволяет "толкать" (push) метрики в него, после чего Prometheus будет их забирать.
    
    #### Когда использовать:
    Pushgateway полезен в следующих случаях:
    - Задачи с коротким сроком жизни (например, cron-задачи), которые завершаются до того, как Prometheus успевает собрать метрики.
    - Сервисы, которые не могут постоянно работать для поддержания HTTP-эндпоинта для сбора метрик.
        
    #### Как работает:
    1. Процесс отправляет метрики в Pushgateway через HTTP-запрос.
    2. Pushgateway хранит эти метрики до тех пор, пока Prometheus не выполнит pull-запрос для их сбора.
    3. Prometheus собирает метрики из Pushgateway, как если бы это был обычный endpoint.
    
    #### Архитектурные особенности:
    - Pushgateway не хранит метрики долгосрочно — он только временно хранит их для последующего сбора Prometheus.
    - Поддерживает метки (`labels`) для различения метрик от разных источников.
    - Можно использовать для нескольких job и instance.
    
    #### Практическое применение:
    - Мониторинг результатов ежедневных бэкапов.
    - Отслеживание состояния batch-процессов (например, импорта данных).
    - Сбор метрик от скриптов деплоя.
    
    #### Ограничения:
    - Не предназначен для хранения долгосрочных метрик.
    - Может стать точкой отказа, если сам Pushgateway недоступен.
    - Требует дополнительного мониторинга состояния Pushgateway.
    
    ---
    
    ### Сравнение и взаимодействие
    
    | Компонент         | Основная задача                              | Применение                                  |
    |-------------------|----------------------------------------------|--------------------------------------------|
    | **Service Discovery** | Автоматическое обнаружение целей           | Динамические инфраструктуры (Kubernetes, AWS) |
    | **Alertmanager**   | Управление алертами                          | Отправка уведомлений о проблемах            |
    | **Pushgateway**    | Сбор метрик от временных процессов          | Мониторинг cron-задач и batch-процессов     |
    
    #### Взаимодействие:
    - Service Discovery помогает Prometheus находить цели для сбора метрик.
    - Prometheus собирает метрики с этих целей и отправляет алерты в Alertmanager.
    - Pushgateway используется для сбора метрик от процессов, которые невозможно мониторить напрямую через pull-модель.
