# Prometheus

### Введение
### Как работает Prometheus и для чего он нужен

**Prometheus** — это система мониторинга с открытым исходным кодом, созданная для сбора и анализа метрик производительности систем и приложений. Он был разработан специально для работы в условиях микросервисной архитектуры и активно используется в экосистеме Kubernetes.

#### **Как работает Prometheus:**
- **Сбор данных:** Prometheus периодически опрашивает (pull) таргеты (цели), которые предоставляют экспортёры (exporters). Экспортёры преобразуют данные из различных источников (например, операционных систем, баз данных, приложений) в формат, понятный Prometheus.
- **Хранение данных:** Собранные метрики хранятся локально в временной базе данных на каждом узле Prometheus. Это позволяет быстро выполнять запросы без необходимости обращаться к внешним хранилищам.
- **Агрегация и анализ:** Prometheus предоставляет мощный язык запросов PromQL (Prometheus Query Language), который позволяет агрегировать, фильтровать и анализировать данные.
- **Алертинг:** Prometheus поддерживает создание правил алертинга, которые могут отправлять уведомления через интеграции с различными системами (например, Slack, PagerDuty, email).
- **Визуализация:** Prometheus может работать с Grafana для создания дашбордов, что позволяет наглядно представлять данные о производительности.

#### **Для чего нужен Prometheus:**
- **Мониторинг производительности:** Отслеживание метрик производительности серверов, контейнеров, баз данных, приложений.
- **Обнаружение проблем:** Быстрое выявление проблем в работе системы через алертинг и анализ метрик.
- **Оптимизация ресурсов:** Анализ использования ресурсов (CPU, память, диск, сеть) для оптимизации инфраструктуры.
- **Прогнозирование:** Использование исторических данных для прогнозирования будущих нагрузок и планирования масштабирования.
- **Интеграция с микросервисами:** Простая интеграция с современными архитектурами, такими как Kubernetes, Docker, и другие облачные платформы.

---

### Pull и Push модель в Prometheus

Prometheus использует **pull модель** по умолчанию, но также поддерживает использование **push модели** через дополнительные компоненты.

#### **Pull модель:**
- **Как работает:**
  - Prometheus регулярно запрашивает (pull) метрики у таргетов (целей), которые должны предоставлять их через HTTP-интерфейс.
  - Интервал опроса настраивается в конфигурационном файле Prometheus.
  - Таргеты могут быть статически настроены или автоматически обнаруживаться через сервисные открытия (service discovery).

- **Преимущества:**
  - Простота реализации: Prometheus управляет всем процессом сбора данных.
  - Надежность: Если таргет недоступен, Prometheus сразу об этом узнает и может сгенерировать алерт.
  - Меньше зависимости от сторонних компонентов.

- **Недостатки:**
  - Не всегда удобно использовать в сценариях, где таргеты находятся за NAT или брандмауэром.
  - Может быть сложно настроить для временных рабочих нагрузок (например, batch jobs).

#### **Push модель:**
- **Как работает:**
  - В push модели данные отправляются (push) в специальный компонент — **Pushgateway**.
  - Приложения или задачи отправляют свои метрики в Pushgateway, а Prometheus затем забирает эти данные с Pushgateway через pull.

- **Когда используется:**
  - Для временных рабочих нагрузок (например, batch jobs), которые не могут существовать достаточно долго для того, чтобы Prometheus мог их опросить.
  - Когда таргеты находятся за NAT или брандмауэром и недоступны напрямую для Prometheus.

- **Преимущества:**
  - Подходит для сценариев, где таргеты недолго существуют или находятся за ограничениями сети.
  - Упрощает работу с временными задачами.

- **Недостатки:**
  - Дополнительная сложность в архитектуре из-за необходимости использования Pushgateway.
  - Вероятность потери данных, если приложение завершается до того, как успело отправить метрики.

---

### Сравнение Pull и Push моделей:

| **Параметр** | **Pull модель** | **Push модель** |
|--------------|-----------------|-----------------|
| **Основной механизм** | Prometheus опрашивает таргеты | Таргеты отправляют данные в Pushgateway |
| **Когда использовать** | Для постоянных сервисов | Для временных задач или защищенных сетей |
| **Зависимость от доступности** | Требует доступности таргетов | Не требует постоянного доступа к таргетам |
| **Компоненты** | Только Prometheus | Prometheus + Pushgateway |
| **Сложность** | Простая | Сlightly более сложная |

---

- Prometheus в основном использует pull модель, которая является более надежной и простой в реализации для большинства случаев.
- Push модель через Pushgateway используется в специальных случаях, таких как временные задачи или ограниченные сетевые условия.
- Выбор между pull и push зависит от конкретных требований вашей инфраструктуры и типов мониторинга.

---

### Основы Prometheus

1. **Четыре золотых сигнала (Four Golden Signals)**:
   [Четыре золотых сигнала](https://play.grafana.org/d/000000109/the-four-golden-signals?orgId=1&from=now-12h&to=now&timezone=browser) — это набор метрик, предложенный Google для мониторинга производительности и здоровья распределённых систем. Они помогают быстро выявлять проблемы и обеспечивать стабильность работы приложений. Эти сигналы включают:

   1. **Latency** (Задержка / Время отклика)

        - Время, которое требуется для обработки запроса.
        - Важно измерять как успешные, так и неудачные запросы.
        - Пример: 95-й перцентиль времени ответа API.

         **Запросы**
         
         Используя Histogram:
         ```promql
         # 95-й процентиль латентности
         histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))
         
         # Среднее время отклика
         avg(rate(http_request_duration_seconds_sum[5m]) 
             / rate(http_request_duration_seconds_count[5m]))
         ```
   
   2. **Traffic** (Трафик / Объем запросов)
      
       - Объём запросов, которые обрабатывает система.
       - Отражает нагрузку на систему.
       - Пример: количество HTTP-запросов в секунду.

         **Запросы**
      
         ```promql
         # Общий объем запросов
         rate(http_requests_total[5m])
         
         # По HTTP методам
         sum(rate(http_requests_total[5m])) by (method)
         
         # По кодам ответов
         sum(rate(http_requests_total[5m])) by (status_code)
         ```
   
   3. **Errors** (Ошибки)

      - Частота ошибок в системе.
      - Включает явные ошибки (например, HTTP 500) и некорректные ответы (например, неверные данные).
      - Пример: процент ошибок от общего числа запросов.
        
         **Запросы**
           
         ```promql
         # Общее количество ошибок
         sum(rate(http_requests_total{status_code=~"5.."}[5m]))
         
         # Процент ошибок (Error Budget)
         (sum(rate(http_requests_total{status_code=~"5.."}[5m]))
          /
          sum(rate(http_requests_total[5m]))) * 100
         
         # Ошибки по методам
         sum(rate(http_requests_total{status_code=~"5.."}[5m])) by (method)
         ```
   
   4. **Saturation** (Нагрузка / Заполненность)

      - Степень загруженности ресурсов системы (CPU, память, диски, сеть).
      - Показывает, насколько система близка к пределу своих возможностей.
      - Пример: использование CPU выше 80%.

         Для CPU:
         ```promql
         # Использование CPU
         100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)
         
         # Средняя загрузка CPU
         avg(node_load1) by (instance)
         ```
         
         Для памяти:
         ```promql
         # Использование памяти
         (node_memory_MemTotal - node_memory_MemFree - node_memory_Buffers - node_memory_Cached)
         / node_memory_MemTotal * 100
         ```
         
         Для дискового пространства:
         ```promql
         # Занятое место на диске
         (node_filesystem_size - node_filesystem_free)
         / node_filesystem_size * 100
         ```
         
         Для сетевого трафика:
         ```promql
         # Пропускная способность сети
         sum(rate(node_network_receive_bytes_total[5m]))
         sum(rate(node_network_transmit_bytes_total[5m]))


2. **Метрика (Metric)** в Prometheus — это числовая характеристика системы, которую можно измерить (например, `http_requests_total`). Она описывает состояние или поведение компонента (CPU, память, ошибки и т.д.).

    **Типы метрик**:
    - **Counter** — монотонно возрастающее значение (например, общее число запросов).
    - **Gauge** — значение, которое может увеличиваться или уменьшаться (например, использование памяти).
    - **Histogram** — группирует данные в "бакеты" (например, время ответа).
    - **Summary** — аналогичен гистограмме, но вычисляет квантили на стороне сервера.

   #### Пример метрики с лейблами:
   
    ```plaintext
    http_requests_total{method="GET", path="/status", status="200"} 1500
    ```
    - **Метрика**: `http_requests_total` (счётчик HTTP-запросов).
    - **Лейблы**: `method`, `path`, `status` (дополнительные атрибуты запроса).
    - **Значение**: 1500 (число успешных GET-запросов к `/status`).

3. **Соотношение золотых сигналов к типам метрик**

   **Таблица**
   
   | **Золотой сигнал** | **Описание** | **Тип метрики** | **Описание** | **Пример метрики** | **Пример запроса** | **Дополнительные комментарии** |
   |--------------------|--------------|-----------------|--------------|--------------------|--------------------|--------------------------------|
   | **Latency** (Латентность) | Время отклика системы | [Histogram/Summary](https://play.grafana.org/d/histogram_tests/histogram-examples?orgId=1&from=now-6h&to=now&timezone=utc) | Гистограмма/Сводка | `http_request_duration_seconds` | `histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))` | Используется для расчета процентилей времени отклика |
   | **Traffic** (Трафик) | Объем входящих запросов | [Counter](https://play.grafana.org/d/000000052/advanced-layout?orgId=1&from=now-3h&to=now&timezone=browser) | Счетчик | `http_requests_total` | `rate(http_requests_total[5m])` | Показывает общее количество запросов за определенный период |
   | **Errors** (Ошибки) | Количество ошибок | [Counter](https://play.grafana.org/d/cL5pLH7Wz/stats-overview?orgId=1&from=now-1h&to=now&timezone=browser) | Счетчик | `http_requests_total{status_code=~"5.."}` | `sum(rate(http_requests_total{status_code=~"5.."}[5m]))` | Фильтрует только ошибочные коды ответа (5xx) |
   | **Saturation** (Загрузка) | Уровень загруженности ресурсов | [Gauge](https://play.grafana.org/d/vmie2cmWz/bar-gauge?orgId=1&from=now-6h&to=now&timezone=utc&refresh=10s) | Индикатор | `node_cpu_seconds_total`, `node_memory_MemTotal` | `100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)` | Измеряет использование CPU, памяти, дискового пространства |
   
   
   **Комментарий к таблице**:
   
   1. **Latency** обычно измеряется с помощью `Histogram` или `Summary`, так как они позволяют рассчитывать процентили.
   2. **Traffic** и **Errors** чаще всего используются с `Counter`, так как это счетчики событий.
   3. **Saturation** использует `Gauge`, так как показывает текущее состояние ресурсов (например, уровень загрузки CPU или использование памяти).





4. **Лейбл (Label)** — это пара ключ-значение, добавляющая контекст к метрике. Например, метрика `http_requests_total` может иметь лейблы `method="POST"`, `path="/api"`, `status_code="200"`, что позволяет группировать и фильтровать данные.

   #### Как используются лейблы в PromQL?
   
   - Фильтрация:  
     `http_requests_total{status="500"}`         # Выведет только 500-ые статусы по лейблу **status**
   - Группировка:  
     `sum by (method) (http_requests_total)`     # Отсортирует сумму по лейблу **method** каждого HTTP запроса
   - Агрегация:  
     `rate(http_requests_total{job="api"}[5m])`  # Cчитает прирост значения метрики за последние 5 минут при обращении к лейблу **job**

5. **Временной ряд (Time Series)** в Prometheus — это последовательность данных, которая описывает изменение метрики во времени. Каждый временной ряд состоит из:

   1. **Имени метрики** (например, `http_requests_total`).
   2. **Набора лейблов** (например, `method="GET"`, `status="200"`, `job="api"`).
   3. **Набора значений**, где каждое значение привязано к определённому моменту времени.

   #### Пример временного ряда:
   ```plaintext
   http_requests_total{method="GET", status="200", job="api"} @timestamp1 => 100
   http_requests_total{method="GET", status="200", job="api"} @timestamp2 => 150
   http_requests_total{method="GET", status="200", job="api"} @timestamp3 => 200
   ```
   Здесь:
   - **Имя метрики**: `http_requests_total`.
   - **Лейблы**: `method="GET"`, `status="200"`, `job="api"`.
   - **Значения**: `100`, `150`, `200` (привязанные к моментам времени `timestamp1`, `timestamp2`, `timestamp3`).



     #### Как временные ряды используются в Prometheus?
      1. **Хранение данных**:  
         Prometheus хранит данные в виде временных рядов. Каждый временной ряд уникально идентифицируется комбинацией имени метрики и лейблов.
      
      2. **Запросы (PromQL)**:  
         Временные ряды используются для анализа данных. Например, вы можете запросить:  
         - Текущее значение:  
           ```promql
           http_requests_total{job="api"}
           ```
         - Скорость изменения:  
           ```promql
           rate(http_requests_total{job="api"}[5m])
           ```
      
      3. **Визуализация**:  
         Временные ряды используются в Grafana или других инструментах для построения графиков.
      
      4. **Алертинг**:  
         На основе временных рядов можно настраивать правила алертинга. Например:  
         ```promql
         rate(http_requests_total{job="api"}[5m]) > 100
         ```
      
      
      #### Как временные ряды создаются?
      1. **Экспортеры**:  
         Экспортеры (например, Node Exporter, Blackbox Exporter) собирают данные и отправляют их в Prometheus в виде временных рядов.
      
      2. **Pushgateway**:  
         Для задач с коротким сроком жизни (например, cron-задачи) данные могут быть отправлены через Pushgateway.
   
6. **Экспортер (Exporter)**
   
   Это специальная программа или сервис, который собирает метрики из внешней системы (например, операционная система, база данных, аппаратное обеспечение) и предоставляет их в формате, понятном Prometheus. Экспортер действует как мост между целевой системой и Prometheus, преобразуя данные в метрики, которые Prometheus может собирать.

      1. **Сбор метрик**:
         - Экспортер собирает данные из целевой системы (например, использование CPU, память, количество запросов к базе данных).
         - Эти данные преобразуются в метрики в формате Prometheus.
      
      2. **Предоставление метрик**:
         - Экспортер предоставляет метрики через HTTP-эндпоинт, обычно в виде простого текстового формата.
         - Пример вывода:
           ```plaintext
           # HELP node_cpu_seconds_total Seconds the CPUs spent in each mode.
           # TYPE node_cpu_seconds_total counter
           node_cpu_seconds_total{cpu="0",mode="user"} 12345.67
           node_cpu_seconds_total{cpu="0",mode="system"} 6789.01
           ```
      
      3. **Сбор метрик Prometheus**:
         - Prometheus периодически запрашивает (вытягивает) метрики с экспортера по HTTP.
         - В конфигурации Prometheus указывается адрес экспортера:
           ```yaml
           scrape_configs:
             - job_name: 'node_exporter'
               static_configs:
                 - targets: ['localhost:9100']
           ```
      
      4. **Анализ и визуализация**:
         - Собранные метрики можно анализировать с помощью PromQL и визуализировать в Grafana.

7. **PromQL**
   
   Это язык запросов для работы с временными рядами в Prometheus. Он позволяет фильтровать, агрегировать и анализировать метрики, вычислять скорости изменения (rate), перцентили (histogram_quantile) и прогнозировать тренды (predict_linear). Используется для мониторинга, визуализации и настройки оповещений. Прост в использовании, но мощный для анализа производительности систем.

   Таблицы с основными функциями агрегирования и запросов в Prometheus, структурированные по категориям:

   #### Таблица 1: Основные агрегирующие функции
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `sum()` | Сумма значений | `sum(http_requests_total)` |
   | `avg()` | Среднее значение | `avg(http_request_duration_seconds)` |
   | `max()` | Максимальное значение | `max(node_memory_MemTotal)` |
   | `min()` | Минимальное значение | `min(node_cpu_seconds_total)` |
   | `stddev()` | Стандартное отклонение | `stddev(http_request_duration_seconds)` |
   | `stdvar()` | Дисперсия | `stdvar(http_request_duration_seconds)` |
   | `count()` | Количество элементов | `count(http_requests_total)` |
   
   ---
   
   #### Таблица 2: Функции для работы со временем
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `rate()` | Скорость изменения за интервал времени | `rate(http_requests_total[5m])` |
   | `irate()` | Скорость изменения между последними двумя точками | `irate(http_requests_total[5m])` |
   | `delta()` | Разница между первым и последним значением | `delta(node_filesystem_free[1h])` |
   | `increase()` | Увеличение счетчика за интервал времени | `increase(http_requests_total[1h])` |
   | `time()` | Текущее время в секундах с Unix epoch | `time()` |
   
   ---
   
   #### Таблица 3: Функции для распределений и квантилей
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `histogram_quantile(φ, ...)` | Расчет квантиля из histogram | `histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))` |
   | `quantile_over_time(φ, ...)` | Расчет квантиля за временной интервал | `quantile_over_time(0.95, http_request_duration_seconds[5m])` |
   | `avg_over_time(...)` | Среднее значение за временной интервал | `avg_over_time(http_request_duration_seconds[5m])` |
   | `max_over_time(...)` | Максимальное значение за временной интервал | `max_over_time(http_request_duration_seconds[5m])` |
   | `min_over_time(...)` | Минимальное значение за временной интервал | `min_over_time(http_request_duration_seconds[5m])` |
   
   ---
   
   #### Таблица 4: Функции для группировки и фильтрации
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `by` | Группировка по указанным меткам | `sum(http_requests_total) by (method)` |
   | `without` | Исключение указанных меток из группировки | `sum(http_requests_total) without (instance)` |
   | `label_replace()` | Замена меток | `label_replace(http_requests_total, "new_label", "$1", "old_label", "(.*)")` |
   | `label_join()` | Объединение меток | `label_join(http_requests_total, "combined", "_", "label1", "label2")` |
   
   ---
   
   #### Таблица 5: Математические и логические функции
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `abs()` | Абсолютное значение | `abs(http_request_duration_seconds)` |
   | `ceil()` | Округление вверх | `ceil(http_request_duration_seconds)` |
   | `floor()` | Округление вниз | `floor(http_request_duration_seconds)` |
   | `round()` | Округление до ближайшего целого | `round(http_request_duration_seconds)` |
   | `clamp_min()` | Ограничение минимального значения | `clamp_min(http_request_duration_seconds, 0)` |
   | `clamp_max()` | Ограничение максимального значения | `clamp_max(http_request_duration_seconds, 10)` |
   
   ---
   
   #### Таблица 6: Логические операторы
   
   | Оператор | Описание | Пример использования |
   |----------|----------|----------------------|
   | `==` | Равно | `http_requests_total == 100` |
   | `!=` | Не равно | `http_requests_total != 0` |
   | `>` | Больше | `http_request_duration_seconds > 1` |
   | `<` | Меньше | `http_request_duration_seconds < 0.5` |
   | `>=` | Больше или равно | `http_requests_total >= 100` |
   | `<=` | Меньше или равно | `http_request_duration_seconds <= 2` |
   
   ---
   
   #### Таблица 7: Встроенные константы и функции
   
   | Константа/Функция | Описание | Пример использования |
   |--------------------|----------|----------------------|
   | `up` | Состояние доступности таргета (1 - доступен, 0 - недоступен) | `up{job="api"}` |
   | `time()` | Текущее время в секундах с Unix epoch | `time()` |
   | `scalar()` | Преобразование в скалярное значение | `scalar(sum(http_requests_total))` |
   | `vector()` | Преобразование в вектор | `vector(1)` |
   
   ---
   
   #### Комментарий к таблицам:
   
   1. **Агрегирующие функции** (`sum`, `avg`, `max`, `min`) используются для объединения данных.
   2. **Функции для работы со временем** (`rate`, `irate`, `delta`, `increase`) помогают анализировать динамику изменений.
   3. **Функции для распределений и квантилей** (`histogram_quantile`, `quantile_over_time`) применяются для анализа гистограмм и summary метрик.
   4. **Группировка и фильтрация** (`by`, `without`, `label_replace`) позволяют управлять метками и группировать данные.
   5. **Математические и логические функции** обеспечивают возможность выполнять различные преобразования и сравнения.
   
   Эти таблицы можно использовать как справочник при написании запросов в Prometheus.


8. **Сервис-дискавери (Service Discovery)**  
    #### Что это:
    Service Discovery — это механизм, который позволяет автоматически обнаруживать сервисы или цели мониторинга в динамических средах. Это особенно важно в современных облачных и контейнеризированных инфраструктурах, где сервисы могут появляться и исчезать динамически (например, в Kubernetes).
    
    #### Как работает:
    Prometheus поддерживает несколько методов Service Discovery, которые позволяют ему автоматически находить и добавлять целевые адреса для сбора метрик. Вот основные типы дискавери:
    
    - **File-based SD**: Prometheus читает список целей из файла, который может быть регулярно обновляемым.
    - **DNS-based SD**: Использует DNS записи для обнаружения новых целей.
    - **Kubernetes SD**: Интеграция с API Kubernetes для автоматического отслеживания подов, сервисов и других ресурсов.
    - **AWS SD**: Обнаружение целей через API AWS (EC2 инстансы, ELB и т.д.).
    - **Consul SD**: Интеграция с HashiCorp Consul для обнаружения сервисов.
    
    #### Архитектурные особенности:
    - Prometheus периодически запрашивает источник Service Discovery для получения актуального списка целей.
    - При изменении инфраструктуры (например, создание нового пода в Kubernetes), Prometheus автоматически обновляет свои цели без необходимости перезапуска.
    - Поддерживается фильтрация целей с помощью label'ов.
    
    #### Практическое применение:
    - В Kubernetes: автоматическое добавление подов с метками `app=example` для мониторинга.
    - В AWS: мониторинг EC2 инстансов, которые соответствуют определенным тегам.
    - В локальных сетях: использование DNS для отслеживания серверов.
    
    #### Преимущества:
    - Упрощение конфигурации в динамических средах.
    - Автоматическая адаптация к изменениям инфраструктуры.
    - Снижение вероятности пропуска новых сервисов при масштабировании.
     
9. **Alertmanager**  
    #### Что это:
    Alertmanager — это компонент экосистемы Prometheus, предназначенный для управления алертами. Он принимает алерты от Prometheus, группирует их, подавляет ненужные уведомления и доставляет их в различные системы оповещения.
    
    #### Как работает:
    Alertmanager работает следующим образом:
    1. Prometheus отправляет алерты на Alertmanager, когда определенные условия выполняются (например, высокая загрузка CPU).
    2. Alertmanager применяет правила маршрутизации для определения получателя уведомления.
    3. Алерты могут быть сгруппированы по общим меткам (например, по сервису или окружению).
    4. Alertmanager отправляет уведомления через настроенные каналы связи (email, Slack, PagerDuty, webhook и т.д.).
    
    #### Основные функции:
    - **Группировка алертов**: Объединяет связанные алерты для предотвращения "шума" (например, все алерты одного сервиса отправляются одним сообщением).
    - **Mute-периоды**: Возможность временно отключать оповещения для определенных условий.
    - **Отложенные оповещения**: Настраиваемые задержки перед отправкой уведомлений.
    - **Маршрутизация**: Гибкая система правил для направления алертов разным получателям.
    - **Эскалация**: Автоматическое повышение уровня важности алерта при отсутствии реакции.
    
    #### Конфигурация:
    Конфигурация Alertmanager происходит через YAML-файл, где можно задать:
    - Маршруты оповещений.
    - Ресиверы (получатели) для разных типов уведомлений.
    - Настройки повторных отправок и mute-периодов.
    
    #### Практическое применение:
    - Отправка уведомлений в Slack о критических проблемах.
    - Интеграция с системами incident management (например, PagerDuty).
    - Автоматическое создание тикетов в Jira при возникновении проблем.
    
    #### Преимущества:
    - Централизованное управление алертами.
    - Защита от информационного шума за счет группировки и эскалации.
    - Гибкая настройка каналов оповещения.
     
10. **Pushgateway**  
    #### Что это:
    Pushgateway — это промежуточный сервис, который используется для сбора метрик от задач с коротким сроком жизни (например, cron-задач или batch-процессов). В отличие от стандартного подхода Prometheus (pull-модель), Pushgateway позволяет "толкать" (push) метрики в него, после чего Prometheus будет их забирать.
    
    #### Когда использовать:
    Pushgateway полезен в следующих случаях:
    - Задачи с коротким сроком жизни (например, cron-задачи), которые завершаются до того, как Prometheus успевает собрать метрики.
    - Сервисы, которые не могут постоянно работать для поддержания HTTP-эндпоинта для сбора метрик.
    - Один-time задачи, такие как скрипты деплоя или проверки состояния.
    
    #### Как работает:
    1. Процесс отправляет метрики в Pushgateway через HTTP-запрос.
    2. Pushgateway хранит эти метрики до тех пор, пока Prometheus не выполнит pull-запрос для их сбора.
    3. Prometheus собирает метрики из Pushgateway, как если бы это был обычный endpoint.
    
    #### Архитектурные особенности:
    - Pushgateway не хранит метрики долгосрочно — он только временно хранит их для последующего сбора Prometheus.
    - Поддерживает метки (`labels`) для различения метрик от разных источников.
    - Можно использовать для нескольких job и instance.
    
    #### Практическое применение:
    - Мониторинг результатов ежедневных бэкапов.
    - Отслеживание состояния batch-процессов (например, импорта данных).
    - Сбор метрик от скриптов деплоя.
    
    #### Ограничения:
    - Не предназначен для хранения долгосрочных метрик.
    - Может стать точкой отказа, если сам Pushgateway недоступен.
    - Требует дополнительного мониторинга состояния Pushgateway.
    
    ---
    
    ### Сравнение и взаимодействие
    
    | Компонент         | Основная задача                              | Применение                                  |
    |-------------------|----------------------------------------------|--------------------------------------------|
    | **Service Discovery** | Автоматическое обнаружение целей           | Динамические инфраструктуры (Kubernetes, AWS) |
    | **Alertmanager**   | Управление алертами                          | Отправка уведомлений о проблемах            |
    | **Pushgateway**    | Сбор метрик от временных процессов          | Мониторинг cron-задач и batch-процессов     |
    
    #### Взаимодействие:
    - Service Discovery помогает Prometheus находить цели для сбора метрик.
    - Prometheus собирает метрики с этих целей и отправляет алерты в Alertmanager.
    - Pushgateway используется для сбора метрик от процессов, которые невозможно мониторить напрямую через pull-модель.
